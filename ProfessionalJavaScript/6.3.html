<!DOCTYPE html>
<html>
<head>
  <title></title>
</head>
<body>
<pre>
  
</pre>
<script type="text/javascript">

// 6.3 继承 

    //继承是 OO语言中的一个最为人津津乐道的概念

  // 6.3.1 原型链

    // 构造函数、原型和实例的关系：
    // 
    // 每个构造函数都有一个原型对象，
    // 实例都包含一个指向原型对象的内部指针
    // 原型对象都包含一个指向构造函数的指针，
  /*  
    function SuperType(){ 
        this.property = true; 
    } 

    SuperType.prototype.getSuperValue = function(){ 
        return this.property; 
    }; 
     
    function SubType(){ 
        this.subproperty = false; 
    } 
     
    //继承了 SuperType 
    SubType.prototype = new SuperType(); 
     
    SubType.prototype.getSubValue = function (){ 
        return this.subproperty; 
    }; 
     
    var instance = new SubType(); 
    alert(instance.getSuperValue());      //true


    alert(instance instanceof Object);         //true 
    alert(instance instanceof SuperType);      //true 
    alert(instance instanceof SubType);         //true


    alert(Object.prototype.isPrototypeOf(instance));         //true 
    alert(SuperType.prototype.isPrototypeOf(instance));      //true 
    alert(SubType.prototype.isPrototypeOf(instance));        //true
  */  

  // 4. 原型链的问题 

  /*
    function SuperType(){ 
        this.colors = ["red", "blue", "green"];
    } 
     
    function SubType(){             
    } 
     
    //继承了 SuperType 
    SubType.prototype = new SuperType(); 
     
    var instance1 = new SubType(); 
    instance1.colors.push("black"); 
    alert(instance1.colors);    
    //"red,blue,green,black" 
     
    var instance2 = new SubType(); 
    alert(instance2.colors);      //"red,blue,green,black"
  */
 

// 6.3.2 借用构造函数 

  /*
    function SuperType(){ 
        this.colors = ["red", "blue", "green"]; 
    } 
     
    function SubType(){   
        //继承了 SuperType 
        SuperType.call(this); 
    } 
     
    var instance1 = new SubType(); 
    instance1.colors.push("black"); 
    alert(instance1.colors);    //"red,blue,green,black" 
     
    var instance2 = new SubType(); 
    alert(instance2.colors);    //"red,blue,green"
  */ 
 
  // 1. 传递参数    

  /*
    function SuperType(name){ 
        this.name = name; 
    } 
     
    function SubType(){   
        //继承了 SuperType，同时还传递了参数 
        SuperType.call(this, "Nicholas"); 
         
        //实例属性 
        this.age = 29; 
    } 
     
    var instance = new SubType(); 
    alert(instance.name);    //"Nicholas"; 
    alert(instance.age);     //29
  */
 
// 6.3.3 组合继承  

  /*  
    function SuperType(name){ 
        this.name = name; 
        this.colors = ["red", "blue", "green"]; 
    } 
     
    SuperType.prototype.sayName = function(){ 
        alert(this.name);
    }; 
     
    function SubType(name, age){   
     
        //继承属性 
        SuperType.call(this, name); 
         
        this.age = age; 
    } 
     
    //继承方法 
    SubType.prototype = new SuperType(); 
    SubType.prototype.constructor = SubType; 
    SubType.prototype.sayAge = function(){ 
        alert(this.age); 
    }; 
     
    var instance1 = new SubType("Nicholas", 29); 
    instance1.colors.push("black"); 
    alert(instance1.colors);      //"red,blue,green,black" 
    instance1.sayName();          //"Nicholas"; 
    instance1.sayAge();           //29 
     
    var instance2 = new SubType("Greg", 27); 
    alert(instance2.colors);      //"red,blue,green" 
    instance2.sayName();          //"Greg"; 
    instance2.sayAge();           //27
  */  


// 6.3.4 原型式继承 

  /*  
    function object(o){ 
        function F(){} 
        F.prototype = o; 
        return new F(); 
    }

    var person = { 
        name: "Nicholas", 
        friends: ["Shelby", "Court", "Van"] 
    }; 
     
    var anotherPerson = object(person); 
    anotherPerson.name = "Greg"; 
    anotherPerson.friends.push("Rob"); 
     
    var yetAnotherPerson = object(person); 
    yetAnotherPerson.name = "Linda"; 
    yetAnotherPerson.friends.push("Barbie"); 
     
    alert(person.friends);   //"Shelby,Court,Van,Rob,Barbie" 
  */  

  // ECMAScript 5
  /*
    var person = { 
        name: "Nicholas", 
        friends: ["Shelby", "Court", "Van"] 
    }; 
     
    var anotherPerson = Object.create(person); 
    anotherPerson.name = "Greg"; 
    anotherPerson.friends.push("Rob"); 
         
    var yetAnotherPerson = Object.create(person); 
    yetAnotherPerson.name = "Linda"; 
    yetAnotherPerson.friends.push("Barbie"); 
     
    alert(person.friends); //"Shelby,Court,Van,Rob,Barbie"
  */  

  /*
    var person = { 
        name: "Nicholas", 
        friends: ["Shelby", "Court", "Van"] 
    };

    var anotherPerson = Object.create(person, { 
        name: { 
            value: "Greg" 
        } 
    }); 
         
    alert(anotherPerson.name); //"Greg
  */  

// 6.3.6 寄生组合式继承
    
  /*  
    function object(o){ 
        function F(){} 
        F.prototype = o; 
        return new F(); 
    }

    function inheritPrototype(subType, superType){ 
        var prototype = object(superType.prototype);     //创建对象 
        prototype.constructor = subType;                 //增强对象 
        subType.prototype = prototype;                   //指定对象 
    } 

    function SuperType(name){ 
        this.name = name; 
        this.colors = ["red", "blue", "green"]; 
    } 
     
    SuperType.prototype.sayName = function(){ 
        alert(this.name); 
    }; 
     
    function SubType(name, age){   
        SuperType.call(this, name); 
         
        this.age = age; 
    } 
     
    inheritPrototype(SubType, SuperType); 
     
    SubType.prototype.sayAge = function(){ 
        alert(this.age); 
    };

    var instance1 = new SubType("Nicholas", 29); 
    instance1.colors.push("black"); 
    alert(instance1.colors);      //"red,blue,green,black" 
    instance1.sayName();          //"Nicholas"; 
    instance1.sayAge();           //29 
     
    var instance2 = new SubType("Greg", 27); 
    alert(instance2.colors);      //"red,blue,green" 
    instance2.sayName();          //"Greg"; 
    instance2.sayAge();           //27

    // 开发人员普遍认为寄生组合式继承是引用类型最理想的继承范式
  */  



















</script>
</body>
</html>